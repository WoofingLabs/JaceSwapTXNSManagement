<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JaceSwap TXNS Management</title>
    <link rel="icon" href="https://woofingjace.com/images/jace.png" type="image/x-icon">
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: linear-gradient(180deg, #1e1e2f 0%, #2a2a3d 100%); color: #ffffff; }
        textarea { width: 100%; height: 200px; margin-bottom: 10px; background: #373b5c; color: #ffffff; border: none; border-radius: 10px; padding: 10px; }
        button { padding: 10px 20px; background: #ff9100; color: #ffffff; border: none; border-radius: 10px; cursor: pointer; margin-right: 10px; }
        button:hover { background: #e68a00; }
        #status { margin-top: 10px; white-space: pre-wrap; color: #ff9100; }
        .settings { margin: 10px 0; }
        .settings label { display: block; margin-bottom: 5px; }
        .settings input, .settings select { width: 200px; margin-bottom: 10px; background: #373b5c; color: #ffffff; border: none; border-radius: 10px; padding: 5px; }
        .container { max-width: 600px; margin: auto; background: #2c2f48; padding: 20px; border-radius: 15px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3); }
        h1 { color: #ff9100; text-align: center; }
    </style>
</head>
<body onload="updateLanguage()">
    <div class="container">
        <h1 id="title">JaceSwap TXNS Management</h1>
        <div class="settings">
            <label id="labelRpcUrl">X Layer RPC URL: <input type="text" id="rpcUrl" value="https://rpc.xlayer.tech"></label>
            <label id="labelChainId">Chain ID: <input type="text" id="chainId" value="196" readonly></label>
            <label id="labelNetworkName">Network Name: <input type="text" id="networkName" value="X Layer mainnet" readonly></label>
            <label id="labelCurrencySymbol">Currency Symbol: <input type="text" id="currencySymbol" value="OKB" readonly></label>
            <label id="labelBlockExplorer">Block Explorer: <input type="text" id="blockExplorer" value="https://www.okx.com/web3/explorer/xlayer" readonly></label>
            <label id="labelSwap">Swap Platform: <select id="swapPlatform">
                <option value="jaceswap">JaceSwap</option>
            </select></label>
            <label id="labelLanguage">Language: <select id="language" onchange="updateLanguage()">
                <option value="en">English</option>
                <option value="zh">中文</option>
            </select></label>
        </div>
        <p id="labelPrivateKeys">Enter one private key per line (with "0x" prefix):</p>
        <textarea id="privateKeys" placeholder="e.g.\n0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef\n0xabcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890"></textarea>
        <div class="settings">
            <label id="labelAmountMin">Min OKB Amount: <input type="number" id="amountMin" value="0.01" step="0.001" min="0.001"></label>
            <label id="labelAmountMax">Max OKB Amount: <input type="number" id="amountMax" value="0.03" step="0.001" min="0.001"></label>
            <label id="labelGasPrice">Gas Price (Gwei): <input type="number" id="gasPrice" value="3.2" step="0.1" min="0"></label>
            <label id="labelGasLimit">Gas Limit: <input type="number" id="gasLimit" value="400000" min="21000"></label>
            <label id="labelProcessInterval">Process Interval (seconds): <input type="number" id="processInterval" value="5" min="1"></label>
            <label id="labelTradeCycles">Trade Cycles per Token: <input type="number" id="tradeCycles" value="1" min="1"></label>
        </div>
        <button id="purchaseButton" onclick="startPurchase()">Start Batch Purchase</button>
        <button id="stopButton" onclick="stopPurchase()" disabled>Stop Purchase</button>
        <button id="checkBalanceButton" onclick="checkBalances()">Check Balances</button>
        <div id="status">Status: Ready</div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/web3@1.7.4/dist/web3.min.js"></script>
    <script>
        const CONTRACTS = {
            jaceswap: {
                routerAddress: "0xdf7837e3E180CeAdE46133946cb1c7c9ECB47F8E",
                wboneAddress: "0xe538905cf8410324e03a5a23c1c177a474d59b2b",
                routerAbi: [
                    {"inputs":[{"internalType":"uint256","name":"amountIn","type":"uint256"},{"internalType":"uint256","name":"amountOutMin","type":"uint256"},{"components":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"bool","name":"stable","type":"bool"}],"internalType":"struct Router.route[]","name":"routes","type":"tuple[]"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"swapExactTokensForTokens","outputs":[{"internalType":"uint256[]","name":"amounts","type":"uint256[]"}],"stateMutability":"nonpayable","type":"function"},
                    {"inputs":[{"internalType":"uint256","name":"amountOutMin","type":"uint256"},{"components":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"bool","name":"stable","type":"bool"}],"internalType":"struct Router.route[]","name":"routes","type":"tuple[]"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"swapExactETHForTokens","outputs":[{"internalType":"uint256[]","name":"amounts","type":"uint256[]"}],"stateMutability":"payable","type":"function"},
                    {"inputs":[{"internalType":"uint256","name":"amountIn","type":"uint256"},{"components":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"bool","name":"stable","type":"bool"}],"internalType":"struct Router.route[]","name":"routes","type":"tuple[]"}],"name":"getAmountsOut","outputs":[{"internalType":"uint256[]","name":"amounts","type":"uint256[]"}],"stateMutability":"view","type":"function"}
                ]
            }
        };

        const WBONE_ABI = [
            {"inputs":[],"name":"deposit","outputs":[],"stateMutability":"payable","type":"function"},
            {"inputs":[{"internalType":"uint256","name":"wad","type":"uint256"}],"name":"withdraw","outputs":[],"stateMutability":"nonpayable","type":"function"},
            {"inputs":[{"internalType":"address","name":"dst","type":"address"},{"internalType":"uint256","name":"wad","type":"uint256"}],"name":"transfer","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},
            {"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"}
        ];

        const ERC20_ABI = [
            {"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
            {"inputs":[],"name":"decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"view","type":"function"}
        ];

        const TOKENS = [
            { name: "USDT", address: "0x1e4a5963abfd975d8c9021ce480b42188849d41d" },
            { name: "USDC", address: "0x74b7f16337b8972027f6196a17a631ac6de26d22" },
            { name: "WETH", address: "0x5a77f1443d16ee5761d310e38b62f77f726bc71c" },
            { name: "JACE", address: "0x4344Ca7bDccb707616f45Aab5Cb843D1D366D483" },
            { name: "STAR", address: "0x552473d6b6b72092aaecd8c4290b91a4db89e7f6" },
            { name: "CHEESE", address: "0xbeeec7010bf4a464c049762bca586f5b30b2baaf" },
            { name: "XDOG", address: "0x0cc24c51bf89c00c5affbfcf5e856c25ecbdb48e" }
        ];

        const messages = {
            en: {
                title: "JaceSwap TXNS Management",
                labelRpcUrl: "X Layer RPC URL: ",
                labelChainId: "Chain ID: ",
                labelNetworkName: "Network Name: ",
                labelCurrencySymbol: "Currency Symbol: ",
                labelBlockExplorer: "Block Explorer: ",
                labelSwap: "Swap Platform: ",
                labelLanguage: "Language: ",
                labelPrivateKeys: "Enter one private key per line (with \"0x\" prefix):",
                privateKeysPlaceholder: "e.g.\n0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef\n0xabcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890",
                labelAmountMin: "Min OKB Amount: ",
                labelAmountMax: "Max OKB Amount: ",
                labelGasPrice: "Gas Price (Gwei): ",
                labelGasLimit: "Gas Limit: ",
                labelProcessInterval: "Process Interval (seconds): ",
                labelTradeCycles: "Trade Cycles per Token: ",
                purchaseButton: "Start Batch Purchase",
                stopButton: "Stop Purchase",
                checkBalanceButton: "Check Balances",
                statusStarting: "Status: Starting...",
                statusReady: "Status: Ready",
                statusStopped: "Status: Stopped",
                testingRPC: "Testing RPC connection...",
                connectedToChain: "Connected to chain ID: ",
                expectedChain: " (X Layer should be 196)",
                chainMismatch: "Error: Not connected to X Layer network (chain ID should be 196).",
                rpcError: "Error: Failed to connect to RPC: ",
                noPrivateKeys: "Error: No private keys provided.",
                invalidPrivateKey: "Error: Invalid private key: ",
                invalidAmountRange: "Error: Max OKB amount must be greater than Min OKB amount.",
                invalidGasPrice: "Error: Invalid Gas Price.",
                invalidGasLimit: "Error: Invalid Gas Limit (minimum 21000).",
                invalidInterval: "Error: Invalid Process Interval (minimum 1 second).",
                invalidTradeCycles: "Error: Invalid Trade Cycles (minimum 1).",
                processingWallet: "Processing wallet ",
                purchasingToken: "Purchasing ",
                forWallet: " for wallet ",
                boneBalance: "OKB Balance: ",
                tokenBalance: "Token Balance: ",
                lowBalanceWarning: "Warning: Wallet ",
                hasLowBalance: " has low OKB balance (",
                mayNotCoverGas: "), may not cover Gas fees.",
                purchaseSuccess: "Purchase successful! Tx: ",
                errorProcessing: "Error processing ",
                errorMessage: ": ",
                allProcessed: "All wallets processed for current token. Moving to next token...",
                allTokensProcessed: "All tokens processed for all wallets.",
                generalError: "Error: ",
                suggestedGasPrice: "Suggested Gas Price: ",
                invalidAmount: "Error: OKB amount too large (max 1000 OKB)."
            },
            zh: {
                title: "JaceSwap 交易管理",
                labelRpcUrl: "X Layer RPC 地址: ",
                labelChainId: "链 ID: ",
                labelNetworkName: "网络名称: ",
                labelCurrencySymbol: "货币符号: ",
                labelBlockExplorer: "区块浏览器: ",
                labelSwap: "Swap 平台: ",
                labelLanguage: "语言: ",
                labelPrivateKeys: "每行输入一个私钥 (带 \"0x\" 前缀):",
                privateKeysPlaceholder: "例如:\n0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef\n0xabcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890",
                labelAmountMin: "最小 OKB 数量: ",
                labelAmountMax: "最大 OKB 数量: ",
                labelGasPrice: "Gas 价格 (Gwei): ",
                labelGasLimit: "Gas 限制: ",
                labelProcessInterval: "处理间隔 (秒): ",
                labelTradeCycles: "每个代币的交易循环次数: ",
                purchaseButton: "开始批量购买",
                stopButton: "停止购买",
                checkBalanceButton: "检查余额",
                statusStarting: "状态: 正在启动...",
                statusReady: "状态: 准备就绪",
                statusStopped: "状态: 已停止",
                testingRPC: "测试 RPC 连接...",
                connectedToChain: "已连接到链 ID: ",
                expectedChain: " (X Layer 应为 196)",
                chainMismatch: "错误: 未连接到 X Layer 网络 (链 ID 应为 196)。",
                rpcError: "错误: 无法连接到 RPC: ",
                noPrivateKeys: "错误: 未提供私钥。",
                invalidPrivateKey: "错误: 无效的私钥: ",
                invalidAmountRange: "错误: 最大 OKB 数量必须大于最小 OKB 数量。",
                invalidGasPrice: "错误: 无效的 Gas 价格。",
                invalidGasLimit: "错误: 无效的 Gas 限制 (最小 21000)。",
                invalidInterval: "错误: 无效的处理间隔 (最小 1 秒)。",
                invalidTradeCycles: "错误: 无效的交易循环次数 (最小 1)。",
                processingWallet: "正在处理钱包 ",
                purchasingToken: "为以下代币购买 ",
                forWallet: " 为钱包 ",
                boneBalance: "OKB 余额: ",
                tokenBalance: "代币余额: ",
                lowBalanceWarning: "警告: 钱包 ",
                hasLowBalance: " 的 OKB 余额低 (",
                mayNotCoverGas: ")，可能无法支付 Gas 费用。",
                purchaseSuccess: "购买成功! 交易: ",
                errorProcessing: "处理时出错 ",
                errorMessage: ": ",
                allProcessed: "当前代币的所有钱包处理完成。切换到下一个代币...",
                allTokensProcessed: "所有代币和钱包处理完成。",
                generalError: "错误: ",
                suggestedGasPrice: "建议 Gas 价格: ",
                invalidAmount: "错误: OKB 数量过大 (最大 1000 OKB)。"
            }
        };

        let isPurchasing = false;

        function getMessage(key) {
            const lang = document.getElementById("language").value;
            return messages[lang][key] || key;
        }

        function updateLanguage() {
            const lang = document.getElementById("language").value;
            document.getElementById("title").textContent = getMessage("title");
            document.getElementById("labelRpcUrl").firstChild.nodeValue = getMessage("labelRpcUrl");
            document.getElementById("labelChainId").firstChild.nodeValue = getMessage("labelChainId");
            document.getElementById("labelNetworkName").firstChild.nodeValue = getMessage("labelNetworkName");
            document.getElementById("labelCurrencySymbol").firstChild.nodeValue = getMessage("labelCurrencySymbol");
            document.getElementById("labelBlockExplorer").firstChild.nodeValue = getMessage("labelBlockExplorer");
            document.getElementById("labelSwap").firstChild.nodeValue = getMessage("labelSwap");
            document.getElementById("labelLanguage").firstChild.nodeValue = getMessage("labelLanguage");
            document.getElementById("labelPrivateKeys").textContent = getMessage("labelPrivateKeys");
            document.getElementById("privateKeys").placeholder = getMessage("privateKeysPlaceholder");
            document.getElementById("labelAmountMin").firstChild.nodeValue = getMessage("labelAmountMin");
            document.getElementById("labelAmountMax").firstChild.nodeValue = getMessage("labelAmountMax");
            document.getElementById("labelGasPrice").firstChild.nodeValue = getMessage("labelGasPrice");
            document.getElementById("labelGasLimit").firstChild.nodeValue = getMessage("labelGasLimit");
            document.getElementById("labelProcessInterval").firstChild.nodeValue = getMessage("labelProcessInterval");
            document.getElementById("labelTradeCycles").firstChild.nodeValue = getMessage("labelTradeCycles");
            document.getElementById("purchaseButton").textContent = getMessage("purchaseButton");
            document.getElementById("stopButton").textContent = getMessage("stopButton");
            document.getElementById("checkBalanceButton").textContent = getMessage("checkBalanceButton");
            document.getElementById("status").textContent = getMessage("statusReady");
        }

        async function initializeWeb3() {
            const rpcUrl = document.getElementById("rpcUrl").value.trim();
            const chainId = parseInt(document.getElementById("chainId").value);
            const expectedChainId = 196;
            const status = document.getElementById("status");

            if (!rpcUrl) {
                status.textContent += getMessage("rpcError") + "Please provide a valid X Layer RPC URL.\n";
                return null;
            }

            const web3 = new Web3(new Web3.providers.HttpProvider(rpcUrl));
            try {
                status.textContent += getMessage("testingRPC") + "\n";
                const networkChainId = await web3.eth.getChainId();
                status.textContent += getMessage("connectedToChain") + networkChainId + getMessage("expectedChain") + "\n";
                if (networkChainId !== expectedChainId) {
                    status.textContent += getMessage("chainMismatch") + "\n";
                    return null;
                }
                return web3;
            } catch (error) {
                status.textContent += getMessage("rpcError") + error.message + "\n";
                return null;
            }
        }

        function getRandomAmount(min, max) {
            return min + Math.random() * (max - min);
        }

        async function tradeCycle(web3, account, tokenAddress, tokenName, swapPlatform, contractInfo, gasPriceWei, gasLimit, processInterval, tradeCycles, amountMin, amountMax) {
            const status = document.getElementById("status");
            const routerContract = new web3.eth.Contract(contractInfo.routerAbi, contractInfo.routerAddress);
            const reserveOKB = web3.utils.toWei("0.01", "ether");

            for (let cycle = 1; cycle <= tradeCycles; cycle++) {
                if (!isPurchasing) {
                    status.textContent += getMessage("statusStopped") + "\n";
                    return false;
                }

                status.textContent += getMessage("processingWallet") + account.address + ` (Cycle ${cycle}/${tradeCycles} for ${tokenName})\n`;

                const balance = await web3.eth.getBalance(account.address);
                const balanceInOKB = web3.utils.fromWei(balance, "ether");
                if (parseFloat(balanceInOKB) < 0.01) {
                    status.textContent += getMessage("lowBalanceWarning") + account.address + getMessage("hasLowBalance") + balanceInOKB + getMessage("mayNotCoverGas") + "\n";
                    return true;
                }

                const okbAmount = getRandomAmount(amountMin, amountMax);
                const okbAmountStr = Number(okbAmount.toFixed(18)).toString();
                const okbWei = web3.utils.toWei(okbAmountStr, "ether");

                if (web3.utils.toBN(balance).lt(web3.utils.toBN(okbWei).add(web3.utils.toBN(reserveOKB)))) {
                    status.textContent += getMessage("lowBalanceWarning") + account.address + getMessage("hasLowBalance") + balanceInOKB + getMessage("mayNotCoverGas") + "\n";
                    return true;
                }

                status.textContent += getMessage("purchasingToken") + tokenName + getMessage("forWallet") + account.address + "...\n";
                try {
                    const deadline = Math.floor(Date.now() / 1000) + 60 * 20;
                    const routes = [{ from: contractInfo.wboneAddress, to: tokenAddress, stable: false }];
                    const txData = routerContract.methods.swapExactETHForTokens(0, routes, account.address, deadline);

                    const estimatedGas = await txData.estimateGas({ from: account.address, value: okbWei });
                    if (estimatedGas > gasLimit) {
                        status.textContent += getMessage("errorProcessing") + account.address + getMessage("errorMessage") + "Gas limit too low, estimated: " + estimatedGas + "\n";
                        return true;
                    }

                    const tx = await txData.send({
                        from: account.address,
                        value: okbWei,
                        gas: Math.min(gasLimit, Math.floor(estimatedGas * 1.2)),
                        gasPrice: gasPriceWei
                    });
                    status.textContent += getMessage("purchaseSuccess") + tx.transactionHash + "\n";
                } catch (error) {
                    status.textContent += getMessage("errorProcessing") + account.address + getMessage("errorMessage") + error.message + "\n";
                    return true;
                }

                await new Promise(resolve => setTimeout(resolve, processInterval));
            }
            return true;
        }

        async function startPurchase() {
            const status = document.getElementById("status");
            status.textContent = getMessage("statusStarting") + "\n";

            const web3 = await initializeWeb3();
            if (!web3) return;

            const swapPlatform = document.getElementById("swapPlatform").value;
            const contractInfo = CONTRACTS[swapPlatform];
            const privateKeys = document.getElementById("privateKeys").value.trim().split("\n").filter(key => key.length > 0);
            const amountMin = parseFloat(document.getElementById("amountMin").value);
            const amountMax = parseFloat(document.getElementById("amountMax").value);
            const gasPriceGwei = parseFloat(document.getElementById("gasPrice").value);
            const gasLimit = parseInt(document.getElementById("gasLimit").value);
            const processInterval = parseInt(document.getElementById("processInterval").value) * 1000;
            const tradeCycles = parseInt(document.getElementById("tradeCycles").value);

            if (privateKeys.length < 1) {
                status.textContent += getMessage("noPrivateKeys") + "\n";
                return;
            }
            if (isNaN(amountMin) || isNaN(amountMax) || amountMin <= 0 || amountMax < amountMin) {
                status.textContent += getMessage("invalidAmountRange") + "\n";
                return;
            }
            if (amountMin > 1000 || amountMax > 1000) {
                status.textContent += getMessage("invalidAmount") + "\n";
                return;
            }
            if (isNaN(gasPriceGwei) || gasPriceGwei <= 0) {
                status.textContent += getMessage("invalidGasPrice") + "\n";
                return;
            }
            if (isNaN(gasLimit) || gasLimit < 21000) {
                status.textContent += getMessage("invalidGasLimit") + "\n";
                return;
            }
            if (isNaN(processInterval) || processInterval < 1000) {
                status.textContent += getMessage("invalidInterval") + "\n";
                return;
            }
            if (isNaN(tradeCycles) || tradeCycles < 1) {
                status.textContent += getMessage("invalidTradeCycles") + "\n";
                return;
            }

            const gasPriceWei = web3.utils.toWei(gasPriceGwei.toString(), "gwei");
            isPurchasing = true;
            document.getElementById("purchaseButton").disabled = true;
            document.getElementById("stopButton").disabled = false;

            try {
                const suggestedGasPrice = await web3.eth.getGasPrice();
                status.textContent += getMessage("suggestedGasPrice") + web3.utils.fromWei(suggestedGasPrice, "gwei") + " Gwei\n";

                while (isPurchasing) {
                    for (const token of TOKENS) {
                        if (!isPurchasing) break;
                        status.textContent += `Starting purchases for ${token.name}...\n`;
                        const tradePromises = privateKeys.map(async (pk) => {
                            let account;
                            try {
                                account = web3.eth.accounts.privateKeyToAccount(pk.trim());
                            } catch (error) {
                                status.textContent += getMessage("invalidPrivateKey") + pk + "\n";
                                return;
                            }
                            web3.eth.accounts.wallet.add(account);
                            const continueTrading = await tradeCycle(web3, account, token.address, token.name, swapPlatform, contractInfo, gasPriceWei, gasLimit, processInterval, tradeCycles, amountMin, amountMax);
                            web3.eth.accounts.wallet.remove(account.address);
                            return continueTrading;
                        });

                        await Promise.all(tradePromises);
                        if (!isPurchasing) break;
                        status.textContent += getMessage("allProcessed") + "\n";
                        await new Promise(resolve => setTimeout(resolve, processInterval));
                    }
                    if (!isPurchasing) break;
                    status.textContent += getMessage("allTokensProcessed") + "\n";
                }
            } catch (error) {
                status.textContent += getMessage("generalError") + error.message + "\n";
            } finally {
                isPurchasing = false;
                document.getElementById("purchaseButton").disabled = false;
                document.getElementById("stopButton").disabled = true;
                status.textContent += getMessage("statusStopped") + "\n";
            }
        }

        function stopPurchase() {
            isPurchasing = false;
            document.getElementById("purchaseButton").disabled = false;
            document.getElementById("stopButton").disabled = true;
            document.getElementById("status").textContent += getMessage("statusStopped") + "\n";
        }

        async function checkBalances() {
            const status = document.getElementById("status");
            status.textContent = getMessage("statusStarting") + "\n";

            const web3 = await initializeWeb3();
            if (!web3) return;

            const swapPlatform = document.getElementById("swapPlatform").value;
            const contractInfo = CONTRACTS[swapPlatform];
            const wboneContract = new web3.eth.Contract(WBONE_ABI, contractInfo.wboneAddress);
            const privateKeys = document.getElementById("privateKeys").value.trim().split("\n").filter(key => key.length > 0);

            if (privateKeys.length < 1) {
                status.textContent += getMessage("noPrivateKeys") + "\n";
                return;
            }

            try {
                for (const pk of privateKeys) {
                    let account;
                    try {
                        account = web3.eth.accounts.privateKeyToAccount(pk.trim());
                    } catch (error) {
                        status.textContent += getMessage("invalidPrivateKey") + pk + "\n";
                        continue;
                    }
                    status.textContent += getMessage("processingWallet") + account.address + "\n";
                    const okbBalance = await web3.eth.getBalance(account.address);
                    status.textContent += getMessage("boneBalance") + web3.utils.fromWei(okbBalance, "ether") + " OKB\n";

                    for (const token of TOKENS) {
                        const tokenContract = new web3.eth.Contract(ERC20_ABI, token.address);
                        const decimals = await tokenContract.methods.decimals().call();
                        const tokenBalance = await tokenContract.methods.balanceOf(account.address).call();
                        status.textContent += getMessage("tokenBalance") + token.name + ": " + (Number(web3.utils.fromWei(tokenBalance, 'ether')) * Math.pow(10, 18 - decimals)).toFixed(4) + " " + token.name + "\n";
                    }
                }
                status.textContent += getMessage("allProcessed") + "\n";
            } catch (error) {
                status.textContent += getMessage("generalError") + error.message + "\n";
            }
        }
    </script>
</body>
</html>
